---
title: "Phthalate & phenol exposure patterns"
subtitle: "& child intelligence in M&N cohort"
author: "Lizzy Gibson"
date: "3/16/2021"
output:
  html_document:
    toc: yes
    toc_float: yes
    code_folding: 'hide'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.align='center', cache=TRUE,
                      autodep = TRUE)
options(scipen = 999)
library(haven)
library(tidyverse)
library(RColorBrewer)
library(mgcv)
library(janitor)
library(gt)
library(reshape2)
library(broom)
library(tableone)
library(xtable)
library(GGally)
library(gtsummary)
library(huxtable)
library(rcompanion)
library(R.matlab)
library(MNdata) # Local package
library(ggsci)
library(patchwork)
library(rstan)
library(bayesplot)
library(shinystan)
library(rstanarm)
library(tictoc)
library(recipes)
library(ggridges)
library(bayestestR)

options(mc.cores = parallel::detectCores())

# theme_set(theme_bw(base_size = 20) + 
#             theme(strip.background = element_rect(fill="white"),
#                   axis.text.x = element_text(angle = 45, hjust = 1),
#                   legend.title = element_text(size = 12),
#                   legend.position = "bottom", 
#                   legend.text = element_text(size = 7)))
# 
# options(
#   ggplot2.discrete.color = pal_nejm()(8),
#   ggplot2.discrete.fill = pal_nejm()(8))
```

```{r, functions}
# Get lower triangle of the correlation matrix
get_lower_tri<-function(x){
  x[upper.tri(x)] <- NA
  
  for (i in 1:nrow(x)) {
    for (j in 1:ncol(x)) {
      if (j == i) {x[i,j] <- NA}
    }
  }
  
  return(x)
}

tidy_ci = function(fit) {
              tidy(fit) %>% bind_cols(., as_tibble(confint(fit)))
}

add_ci4interaction <- function(fit, term1, term2) {
    # CONFIDENCE INTERVAL for pattern in females
    # Compute association and its uncertainty 
    
    # here we create tables of coefficients and covariance
    coef.mat <- summary(fit)$coefficients
    var.mat  <- vcov(fit)
    
    # the total term for the association is the 
    # sum of P2 in the reference sex plus the term for P2:female
    beta.Pf <- coef.mat[term1,1] + coef.mat[term2,1]
    
    # Compute variance in order to compute standard error
    # We must compute the variance for the total term 
    # Var(Beta1 + Beta2) = Var(Beta1) + Var(Beta2) + 2*CoVar(Beta1, Beta2) 
    var.Pf <- var.mat[term1, term1] + 
              var.mat[term2, term2] +
              2*var.mat[term1, term2]
    
    # this is st error NOT std
    ste.Pf  <-  sqrt(abs(var.Pf))

    # compute confidence intervals 
    lci.Pf <- beta.Pf - 1.96*ste.Pf
    uci.Pf <- beta.Pf + 1.96*ste.Pf
    
    # 2 calculate the test statistic: t = Est/SE
    # 3 calculate the P value2: P = exp(−0.717×z − 0.416×z2).
    test_stat = abs(beta.Pf/ste.Pf)
    pvalue = exp(-0.717*test_stat - 0.416*test_stat^2)
    pvalue
    
    tidy_ci(fit) %>% 
      bind_rows(., tibble(term = paste0(term1, " in females"), estimate = beta.Pf, std.error = ste.Pf,
                statistic = test_stat, p.value = pvalue, `2.5 %` = lci.Pf, `97.5 %` = uci.Pf)) %>% 
      mutate(term = ifelse(term == term1, paste(term1, "in males"), term))
}

add_ci4int_bayes = function(fit) {
int_sum = summary(fit, c("beta_int", "beta_sex", "beta_p"))$summary

params = names(p1_non)[grep("(alpha|beta)", names(p1_non))]
model_sum = summary(fit, params)$summary

ext <- extract(fit)

post_coef = cbind(ext$alpha, ext$beta_c, 
                     ext$beta_int, ext$beta_sex, ext$beta_p) %>% as_tibble()

colnames(post_coef) = params
int_coefs = post_coef %>% dplyr::select(beta_p, beta_int)

coef1 = int_coefs$beta_p
coef2 = int_coefs$beta_int

covmat = cov(int_coefs)
beta_f = coef1 + coef2

var_f = covmat[1, 1] + 
              covmat[2, 2] +
              2*covmat[1, 2]

# this is std dev not std error
sd_f  <- sqrt(abs(var_f))

# take min sample size as conservative est.
sampsize = min(int_sum[1,9], int_sum[3,9])

# this is std error
se_f  <- sd_f/sqrt(sampsize)

lci.f <- mean(beta_f) - 1.96*se_f
uci.f <- mean(beta_f) + 1.96*se_f

# 2 calculate the test statistic: t = Est/SE
# 3 calculate the P value2: P = exp(−0.717×z − 0.416×z2).
# test_stat = abs(mean(beta_f)/se_f)
# pvalue = exp(-0.717*test_stat - 0.416*test_stat^2)
# NO BAYESIAN PVALUE

q = quantile(beta_f, probs = c(0.025, .25, .50, .75, .975)) %>% as.data.frame() %>% 
  rownames_to_column() %>% 
  pivot_wider(names_from = "rowname",
              values_from = ".")

new_var = tibble(beta = "p in females", mean = round(mean(beta_f), 4), 
                 se_mean = round(se_f,4), sd = round(sd_f,4)) %>% 
          bind_cols(., q)

as.data.frame(model_sum)[,-c(9:10)] %>% 
  rownames_to_column(var="beta") %>% 
  mutate(beta = c("alpha", "age", "edu", "marital", "home", "iq", "alcohol", "smoker",
                  "sex*p", "sex", "p in males")) %>% 
  bind_rows(.,new_var) %>% 
  mutate_at(vars(2:9), round, 2)
}
```

## Mothers & Newborns

* 5 phenols  
* 3 parabens  
* 9 phthalates  

```{r, dat}
e_wa <- readMat(here::here("./Data/mn2_EWA_sd1.mat"))[[1]] %>% as_tibble() %>% rename(P2 = V1, P1 = V2)
var_wa <- readMat(here::here("./Data/mn2_WA_var_sd1.mat"))[[1]] %>% as_tibble() %>% rename(varP2 = V1, varP1 = V2)

summary(e_wa)
apply(e_wa, 2, sd)

summary(var_wa)
apply(var_wa, 2, sd)

bayes = bind_cols(ppp_cov, e_wa, var_wa) %>% 
        dplyr::select(-GEST, -ETH) %>% 
        rename(HOME_SCORE = HOMETOT) %>% 
        filter(P2 < mean(P2) + 5*sd(P2)) %>% # removes two females, 1 male
        drop_na() %>% 
        mutate_at(vars(c(HOME_SCORE, M_AGE, M_IQ)), scale)

# For stan model ####
N = nrow(bayes)
C = ncol(bayes) - 6 - 1
x = model.matrix(WISC ~ M_AGE + M_EDU + MARITAL_STATUS + HOME_SCORE + M_IQ + ALCOHOL + SMOKER_IN_HOME, 
                 data = bayes)[,-1]
sex = model.matrix(WISC ~ SEX, data = bayes)[,-1]
y = bayes$WISC
sd(y)

P2 = bayes$P2
P1 = bayes$P1

sd_ewa = bayes %>% dplyr::select(varP2:varP1) %>% mutate_all(~sqrt(.))
sdP1 = sd_ewa$varP1
sdP2 = sd_ewa$varP2
```

```{r, standat}
p2_data = list(N = N,
                  C = C,
                  x = x,
                  y = y,
                  sex = sex,
                  ewa = P2,
                  sd_ewa = sdP2)

p1_data = list(N = N,
                  C = C,
                  x = x,
                  y = y,
                  sex = sex,
                  ewa = P1,
                  sd_ewa = sdP1)
```

## Bayesian models

```{r}
# p2_non <- stan(
#   file = "bn2mf_score_reg_int.stan",  # Stan program
#     data = p2_data,               # named list of data
#     chains = 4,                   # number of Markov chains
#     warmup = 1000,                # number of warmup iterations per chain
#     iter = 5000,                  # total number of iterations per chain
#     cores = 2)                    # number of cores
# save(p2_non, file = "./Stan/pattern2_noninf_fit.rda")

# p1_non <- stan(
#   file = "bn2mf_score_reg_int.stan",  # Stan program
#     data = p1_data,               # named list of data
#     chains = 4,                   # number of Markov chains
#     warmup = 1000,                # number of warmup iterations per chain
#     iter = 5000,                  # total number of iterations per chain
#     cores = 2)                    # number of cores
# save(p1_non, file = "./Stan/pattern1_noninf_fit.rda")

# p2_inf <- stan(
#   file = "bn2mf_score_reg_int_infp2.stan",  # Stan program
#     data = p2_data,               # named list of data
#     chains = 4,                   # number of Markov chains
#     warmup = 1000,                # number of warmup iterations per chain
#     iter = 5000,                  # total number of iterations per chain
#     cores = 2)                    # number of cores
# save(p2_inf, file = "./Stan/pattern2_inf_fit.rda")

# p1_inf <- stan(
#   file = "bn2mf_score_reg_int_infp1.stan",  # Stan program
#     data = p1_data,               # named list of data
#     chains = 4,                   # number of Markov chains
#     warmup = 1000,                # number of warmup iterations per chain
#     iter = 5000,                  # total number of iterations per chain
#     cores = 2)                    # number of cores
# save(p1_inf, file = "./Stan/pattern1_inf_fit.rda")

# p2_infpnonc <- stan(
#   file = "bn2mf_score_reg_int_infp2_nonc.stan",  # Stan program
#     data = p2_data,               # named list of data
#     chains = 4,                   # number of Markov chains
#     warmup = 1000,                # number of warmup iterations per chain
#     iter = 5000,                  # total number of iterations per chain
#     cores = 2)                    # number of cores
# save(p2_infpnonc, file = "./Stan/pattern2_infp2nonc_fit.rda")

# p1_infpnonc <- stan(
#   file = "bn2mf_score_reg_int_infp1_nonc.stan",  # Stan program
#     data = p1_data,               # named list of data
#     chains = 4,                   # number of Markov chains
#     warmup = 1000,                # number of warmup iterations per chain
#     iter = 5000,                  # total number of iterations per chain
#     cores = 2)                    # number of cores
# save(p1_infpnonc, file = "./Stan/pattern1_infp1nonc_fit.rda")
```

```{r, stan}
load("./Stan/pattern2_noninf_fit.rda")
load("./Stan/pattern2_inf_fit.rda")
load("./Stan/pattern1_noninf_fit.rda")
load("./Stan/pattern1_inf_fit.rda")

load("./Stan/pattern2_infp_nonc.rda")
load("./Stan/pattern1_infp_nonc.rda")
```

### Summary

#### Pattern 1

##### Non-informative
```{r, p1non}
params = names(p1_non)[grep("(alpha|beta)", names(p1_non))]
print(p1_non, params)
```

##### Informative
```{r, p1inf}
print(p1_inf, params)
```

#### Pattern 2

##### Non-informative
```{r, p2non}
print(p2_non, params)
```

##### Informative
```{r, p2inf}
print(p2_inf, params)
```

### Posterior prediction

#### Pattern 1

##### Non-informative
```{r, p1pppnon}
y = bayes$WISC

# Extract fit
ext_p1 <- extract(p1_non)

y_pred_p1 = ext_p1$y_tilde

# random sample of y
samp = sample(1:16000, 75) # (5000-1000 warmup) * 4
y_post_samp_p1 = y_pred_p1[samp,]

# plot posterior prediction
color_scheme_set("brightblue")
ppc_dens_overlay(y = as.vector(y),
                 yrep = as.matrix(y_post_samp_p1)) +
  labs(y = "Density",
       title = "Posterior predicted distribution",
       subtitle = "overlaid on measured density",
       x = "Full Scale WISC")
```

##### Informative
```{r, p1pppinf}
# Extract fit
ext_p1i <- extract(p1_inf)

y_pred_p1i = ext_p1i$y_tilde

# random sample of y
y_post_samp_p1i = y_pred_p1i[samp,]

# plot posterior prediction
color_scheme_set("brightblue")
ppc_dens_overlay(y = as.vector(y),
                 yrep = as.matrix(y_post_samp_p1i)) +
  labs(y = "Density",
       title = "Posterior predicted distribution",
       subtitle = "overlaid on measured density",
       x = "Full Scale WISC")
```

#### Pattern 2

##### Non-informative
```{r, p2pppnon}
# Extract fit
ext_p2 <- extract(p2_non)

y_pred_p2 = ext_p2$y_tilde

# random sample of y
y_post_samp_p2 = y_pred_p2[samp,]

# plot posterior prediction
color_scheme_set("brightblue")
ppc_dens_overlay(y = as.vector(y),
                 yrep = as.matrix(y_post_samp_p2)) +
  labs(y = "Density",
       title = "Posterior predicted distribution",
       subtitle = "overlaid on measured density",
       x = "Full Scale WISC")
```

##### Informative
```{r, p2pppinf}
# Extract fit
ext_p2i <- extract(p2_inf)

y_pred_p2i = ext_p2i$y_tilde

# random sample of y
y_post_samp_p2i = y_pred_p2i[samp,]

# plot posterior prediction
color_scheme_set("brightblue")
ppc_dens_overlay(y = as.vector(y),
                 yrep = as.matrix(y_post_samp_p2i)) +
  labs(y = "Density",
       title = "Posterior predicted distribution",
       subtitle = "overlaid on measured density",
       x = "Full Scale WISC")
```

### Coefficients of interest

#### Pattern 1

##### Non-informative
```{r, p1coefnon}
# Plot pattern beta coefficient with uncertainty
color_scheme_set("brightblue")
mcmc_areas(p1_non,
           pars = params[(length(params)-2):length(params)],
           prob = 0.95) + ggtitle("Posterior distributions",
                                  "with medians and 95% intervals") +
  scale_y_discrete(labels=c(
  "beta_int" = "Interaction", 
  "beta_sex" =  "Sex female",
  "beta_p" = "P1 in males")) + xlim(c(-17,17))
```

##### Informative
```{r, p1coefinf}
# Plot pattern beta coefficient with uncertainty
color_scheme_set("brightblue")
mcmc_areas(p1_inf,
           pars = params[(length(params)-2):length(params)],
           prob = 0.95) + ggtitle("Posterior distributions",
                                  "with medians and 95% intervals") +
  scale_y_discrete(labels=c(
  "beta_int" = "Interaction", 
  "beta_sex" =  "Sex female",
  "beta_p" = "P1 in males")) + xlim(c(-17,17))
```

#### Pattern 2

##### Non-informative
```{r, p2coefnon}
# Plot pattern beta coefficient with uncertainty
color_scheme_set("brightblue")
mcmc_areas(p2_non,
           pars = params[(length(params)-2):length(params)],
           prob = 0.95) + ggtitle("Posterior distributions",
                                  "with medians and 95% intervals") +
  scale_y_discrete(labels=c(
  "beta_int" = "Interaction", 
  "beta_sex" =  "Sex female",
  "beta_p" = "P2 in males")) + xlim(c(-12,12))
```

##### Informative
```{r, p2coefinf}
# Plot pattern beta coefficient with uncertainty
color_scheme_set("brightblue")
mcmc_areas(p2_inf,
           pars = params[(length(params)-2):length(params)],
           prob = 0.95) + ggtitle("Posterior distributions",
                                  "with medians and 95% intervals") +
  scale_y_discrete(labels=c(
  "beta_int" = "Interaction", 
  "beta_sex" =  "Sex female",
  "beta_p" = "P1 in males")) + xlim(c(-12,12))
```

### Patterns by sex

#### Pattern 1

##### Non-informative
```{r, p1patnon}
add_ci4int_bayes(p1_non)
```

##### Informative
```{r, p1patinf}
add_ci4int_bayes(p1_inf)
```

#### Pattern 2

##### Non-informative
```{r, p2patnon}
add_ci4int_bayes(p2_non)
```

##### Informative
```{r, p2patinf}
add_ci4int_bayes(p2_inf)
```

### Viz

#### Pattern 1

#### Non-informative
```{r}
p1non_coef = cbind(ext_p1$beta_int, ext_p1$beta_sex, ext_p1$beta_p) %>% 
  as_tibble() %>% 
  rename(int=1, sex=2, p_male=3) %>% 
             mutate(p_female = p_male + int) %>% 
  dplyr::select(-sex)

mcmc_areas(p1non_coef,
           prob = 0.95) + ggtitle("Posterior distributions",
                                  "with medians and 95% intervals") +
  scale_y_discrete(labels=c(
  "int" = "Interaction", 
  "p_male" = "P2 in males",
  "p_female" = "P2 in females")) + xlim(c(-9,9))
```

#### Informative
```{r}
p1i_coef = cbind(ext_p1i$beta_int, ext_p1i$beta_sex, ext_p1i$beta_p) %>% 
  as_tibble() %>% 
  rename(int=1, sex=2, p_male=3) %>% 
             mutate(p_female = p_male + int) %>% 
  dplyr::select(-sex)

mcmc_areas(p1i_coef,
           prob = 0.95) + ggtitle("Posterior distributions",
                                  "with medians and 95% intervals") +
  scale_y_discrete(labels=c(
  "int" = "Interaction", 
  "p_male" = "P2 in males",
  "p_female" = "P2 in females")) + xlim(c(-9,9))
```

#### Pattern 2

#### Non-informative
```{r}
p2non_coef = cbind(ext_p2$beta_int, ext_p2$beta_sex, ext_p2$beta_p) %>% 
  as_tibble() %>% 
  rename(int=1, sex=2, p_male=3) %>% 
             mutate(p_female = p_male + int) %>% 
  dplyr::select(-sex)

mcmc_areas(p2non_coef,
           prob = 0.95) + ggtitle("Posterior distributions",
                                  "with medians and 95% intervals") +
  scale_y_discrete(labels=c(
  "int" = "Interaction", 
  "p_male" = "P2 in males",
  "p_female" = "P2 in females")) + xlim(c(-11,11))
```

#### Informative
```{r}
p2i_coef = cbind(ext_p2i$beta_int, ext_p2i$beta_sex, ext_p2i$beta_p) %>% 
  as_tibble() %>% 
  rename(int=1, sex=2, p_male=3) %>% 
             mutate(p_female = p_male + int) %>% 
  dplyr::select(-sex)

mcmc_areas(p2i_coef,
           prob = 0.95) + ggtitle("Posterior distributions",
                                  "with medians and 95% intervals") +
  scale_y_discrete(labels=c(
  "int" = "Interaction", 
  "p_male" = "P2 in males",
  "p_female" = "P2 in females")) + xlim(c(-11,11))
```

```{r, include = F}
color_scheme_view("brightblue")
color_scheme_get("brightblue")

plot_area = function(data) {

  # Get kernel density estimate as a data frame
  dens = map_df(data, ~ {
    d = density(.x, na.rm=TRUE)
    tibble(x=d$x, y=d$y)
  }, .id="name")
  
  # Set relative width of median line
  e = diff(range(dens$x)) * 0.003
  
  # Get credible interval width and median
  cred.int = data %>% 
    pivot_longer(cols=everything()) %>% 
    group_by(name) %>% 
    summarise(CI=list(eti(value, ci=.95)),
              m=median(value, na.rm=TRUE)) %>% 
    unnest_wider(CI)
  
dens_plt = dens %>% left_join(cred.int) 

dens_plt %>% 
    ggplot(aes(y=name, x=x, height=y), color = "#cce5ff") +
      geom_vline(xintercept=0, colour="grey70", linetype = "dashed") +
      geom_ridgeline(data= dens_plt %>% group_by(name) %>%
                       filter(x >= CI_low & x <= CI_high),
                     fill="#cce5ff") +
      geom_ridgeline(data= dens_plt %>% group_by(name) %>% 
                       filter(x >= (m-e) & x<= (m+e)),
                     fill="#198bff") +
      geom_ridgeline(fill=NA, color = "#0065cc") + 
      geom_ridgeline(fill=NA, aes(height=0), color = "#0065cc") +
      labs(y=NULL, x=NULL) +
    scale_y_discrete(labels=c(
  "int" = "Interaction", 
  "p_male" = "Pattern in males",
  "p_female" = "Pattern in females")) + 
  ggtitle("Posterior distributions", "with medians and 95% intervals") 
}

plot_area(p2i_coef)
```

