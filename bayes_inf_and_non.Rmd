---
title: "Phthalate & phenol exposure patterns"
subtitle: "& child intelligence in M&N cohort"
author: "Lizzy Gibson"
date: "3/16/2021"
output:
  html_document:
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.align='center', echo=FALSE)
options(scipen = 999)
library(haven)
library(tidyverse)
library(RColorBrewer)
library(mgcv)
library(janitor)
library(gt)
library(reshape2)
library(broom)
library(tableone)
library(xtable)
library(GGally)
library(gtsummary)
library(huxtable)
library(rcompanion)
library(R.matlab)
library(MNdata) # Local package
library(ggsci)
library(patchwork)
library(rstan)
library(bayesplot)
library(shinystan)
library(rstanarm)
library(tictoc)
library(recipes)

options(mc.cores = parallel::detectCores())

theme_set(theme_bw(base_size = 20) + 
            theme(strip.background = element_rect(fill="white"),
                  axis.text.x = element_text(angle = 45, hjust = 1),
                  legend.title = element_text(size = 12),
                  legend.position = "bottom", 
                  legend.text = element_text(size = 7)))

options(
  ggplot2.discrete.color = pal_nejm()(8),
  ggplot2.discrete.fill = pal_nejm()(8))
```

```{r, functions}
# Get lower triangle of the correlation matrix
get_lower_tri<-function(x){
  x[upper.tri(x)] <- NA
  
  for (i in 1:nrow(x)) {
    for (j in 1:ncol(x)) {
      if (j == i) {x[i,j] <- NA}
    }
  }
  
  return(x)
}

tidy_ci = function(fit) {
              tidy(fit) %>% bind_cols(., as_tibble(confint(fit)))
}

add_ci4interaction <- function(fit, term1, term2) {
    # CONFIDENCE INTERVAL for pattern in females
    # Compute association and its uncertainty 
    
    # here we create tables of coefficients and covariance
    coef.mat <- summary(fit)$coefficients
    var.mat  <- vcov(fit)
    
    # the total term for the association is the 
    # sum of P2 in the reference sex plus the term for P2:female
    beta.Pf <- coef.mat[term1,1] + coef.mat[term2,1]
    
    # Compute variance in order to compute standard error
    # We must compute the variance for the total term 
    # Var(Beta1 + Beta2) = Var(Beta1) + Var(Beta2) + 2*CoVar(Beta1, Beta2) 
    var.Pf <- var.mat[term1, term1] + 
              var.mat[term2, term2] +
              2*var.mat[term1, term2]
    
    # this is st error NOT std
    ste.Pf  <-  sqrt(abs(var.Pf))

    # compute confidence intervals 
    lci.Pf <- beta.Pf - 1.96*ste.Pf
    uci.Pf <- beta.Pf + 1.96*ste.Pf
    
    # 2 calculate the test statistic: t = Est/SE
    # 3 calculate the P value2: P = exp(−0.717×z − 0.416×z2).
    test_stat = abs(beta.Pf/ste.Pf)
    pvalue = exp(-0.717*test_stat - 0.416*test_stat^2)
    pvalue
    
    tidy_ci(fit) %>% 
      bind_rows(., tibble(term = paste0(term1, " in females"), estimate = beta.Pf, std.error = ste.Pf,
                statistic = test_stat, p.value = pvalue, `2.5 %` = lci.Pf, `97.5 %` = uci.Pf)) %>% 
      mutate(term = ifelse(term == term1, paste(term1, "in males"), term))
}

add_ci4int_bayes = function(fit) {
int_sum = summary(fit, c("beta_int", "beta_sex", "beta_p"))$summary

ext <- extract(fit)

post_coef = cbind(ext$alpha, ext$sigma, ext$beta_c, 
                     ext$beta_int, ext$beta_sex, ext$beta_p) %>% as_tibble()

colnames(post_coef) = params
int_coefs = post_coef %>% dplyr::select(beta_p, beta_int)

coef1 = int_coefs$beta_p
coef2 = int_coefs$beta_int

covmat = cov(int_coefs)
beta_f = coef1 + coef2

var_f = covmat[1, 1] + 
              covmat[2, 2] +
              2*covmat[1, 2]

# this is std dev not std error
sd_f  <- sqrt(abs(var_f))

# take min sample size as conservative est.
sampsize = min(int_sum[1,9], int_sum[3,9])

# this is std error
se_f  <- sd_f/sqrt(sampsize)

lci.f <- mean(beta_f) - 1.96*se_f
uci.f <- mean(beta_f) + 1.96*se_f

# 2 calculate the test statistic: t = Est/SE
# 3 calculate the P value2: P = exp(−0.717×z − 0.416×z2).
# test_stat = abs(mean(beta_f)/se_f)
# pvalue = exp(-0.717*test_stat - 0.416*test_stat^2)
# NO BAYESIAN PVALUE

q = quantile(beta_f, probs = c(0.025, .25, .50, .75, .975)) %>% as.data.frame() %>% 
  rownames_to_column() %>% 
  pivot_wider(names_from = "rowname",
              values_from = ".")

new_var = tibble(beta = "P in females", mean = round(mean(beta_f), 4), 
                 se_mean = round(se_f,4), sd = round(sd_f,4)) %>% 
          bind_cols(., q)

as.data.frame(int_sum)[,-c(9:10)] %>% rownames_to_column(var="beta") %>% 
  bind_rows(.,new_var) %>% 
  mutate(beta = ifelse(beta == "beta_p", "P in males", beta))
}
```

## Mothers & Newborns

* 5 phenols  
* 3 parabens  
* 9 phthalates  

```{r, dat, cache=T}
e_wa <- readMat(here::here("./Data/mn2_EWA_sd1.mat"))[[1]] %>% as_tibble() %>% rename(P2 = V1, P1 = V2)
var_wa <- readMat(here::here("./Data/mn2_WA_var_sd1.mat"))[[1]] %>% as_tibble() %>% rename(varP2 = V1, varP1 = V2)

bayes_int = bind_cols(ppp_cov, e_wa, var_wa) %>% 
        dplyr::select(-GEST, -ETH) %>% 
        rename(HOME_SCORE = HOMETOT) %>% 
        filter(P2 < mean(P2) + 5*sd(P2)) %>% # removes two females, 1 male
        drop_na() %>% 
        mutate_at(vars(c(HOME_SCORE, M_AGE, M_IQ)), scale)

# For stan model ####
N = nrow(bayes_int)
C = ncol(bayes_int) - 6 - 1
x = model.matrix(WISC ~ M_AGE + M_EDU + MARITAL_STATUS + HOME_SCORE + M_IQ + ALCOHOL + SMOKER_IN_HOME, 
                 data = bayes_int)[,-1]
sex = model.matrix(WISC ~ SEX, data = bayes_int)[,-1]
y = bayes_int$WISC
P2 = bayes_int$P2
P1 = bayes_int$P1

sd_ewa = bayes_int %>% dplyr::select(varP2:varP1) %>% mutate_all(~sqrt(.))
sdP1 = sd_ewa$varP1
sdP2 = sd_ewa$varP2
```

```{r, standat, cache=T}
p2_data = list(N = N,
                  C = C,
                  x = x,
                  y = y,
                  sex = sex,
                  ewa = P2,
                  sd_ewa = sdP2)

p1_data = list(N = N,
                  C = C,
                  x = x,
                  y = y,
                  sex = sex,
                  ewa = P1,
                  sd_ewa = sdP1)
```

## Bayesian models

```{r, stan, cache=T}
p2_non <- stan(
  file = "bn2mf_score_reg_int.stan",  # Stan program
    data = p2_data,               # named list of data
    chains = 4,                   # number of Markov chains
    warmup = 1000,                # number of warmup iterations per chain
    iter = 5000,                  # total number of iterations per chain
    cores = 2)                    # number of cores
  
p1_non <- stan(
  file = "bn2mf_score_reg_int.stan",  # Stan program
    data = p1_data,               # named list of data
    chains = 4,                   # number of Markov chains
    warmup = 1000,                # number of warmup iterations per chain
    iter = 5000,                  # total number of iterations per chain
    cores = 2)                    # number of cores

p2_inf <- stan(
  file = "bn2mf_score_reg_int_inf.stan",  # Stan program
    data = p2_data,               # named list of data
    chains = 4,                   # number of Markov chains
    warmup = 1000,                # number of warmup iterations per chain
    iter = 5000,                  # total number of iterations per chain
    cores = 2)                    # number of cores
  
p1_inf <- stan(
  file = "bn2mf_score_reg_int_inf.stan",  # Stan program
    data = p1_data,               # named list of data
    chains = 4,                   # number of Markov chains
    warmup = 1000,                # number of warmup iterations per chain
    iter = 5000,                  # total number of iterations per chain
    cores = 2)                    # number of cores
```

### Pattern 1

```{r}
params = names(p1_fit)[grep("(alpha|sigma|beta)", names(p1_fit))]
print(p1_fit, params)
```

### Pattern 2

```{r}
params = names(p2_fit)[grep("(alpha|sigma|beta)", names(p2_fit))]
print(p2_fit, params)
```

### Posterior prediction

#### Pattern 1

```{r}
bayes_int = mn %>% 
        dplyr::select(-GEST, -ETH) %>% 
        drop_na()
y = bayes_int$WISC

# Extract fit
ext_p1 <- extract(p1_fit)

y_pred_p1 = ext_p1$y_tilde

# random sample of y
samp = sample(1:16000, 75) # (5000-1000 warmup) * 4
y_post_samp_p1 = y_pred_p1[samp,]

# plot posterior prediction
color_scheme_set("brightblue")
ppc_dens_overlay(y = as.vector(y),
                 yrep = as.matrix(y_post_samp_p1)) +
  labs(y = "Density",
       title = "Posterior predicted distribution",
       subtitle = "overlaid on measured density",
       x = "Full Scale WISC")
```


### Coefficients of interest

#### Pattern 1

```{r}
# Plot pattern beta coefficient with uncertainty
color_scheme_set("brightblue")
mcmc_areas(p1_fit,
           pars = params[(length(params)-2):length(params)],
           prob = 0.95) + ggtitle("Posterior distributions",
                                  "with medians and 95% intervals") +
  scale_y_discrete(labels=c(
  "beta_int" = "Interaction", 
  "beta_sex" =  "Sex female",
  "beta_p" = "P1 in males"))
```

#### Pattern 2

```{r}
# Plot pattern beta coefficient with uncertainty
color_scheme_set("brightblue")
mcmc_areas(p2_fit,
           pars = params[(length(params)-2):length(params)],
           prob = 0.95) + ggtitle("Posterior distributions",
                                  "with medians and 95% intervals") +
  scale_y_discrete(labels=c(
  "beta_int" = "Interaction", 
  "beta_sex" =  "Sex female",
  "beta_p" = "P2 in males"))
```

### Patterns by sex

#### Pattern 1

```{r}
add_ci4int_bayes(p1_fit)
```

#### Pattern 2

```{r}
add_ci4int_bayes(p2_fit)
```

  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  
  <br>  

## Extra

### Some missingness
  
**Are the people missing WISC the same as the people missing HOME?**  
  
There are `r ppp_current %>% filter(is.na(HOME_SCORE)) %>% nrow()` people missing `HOME` and `r ppp_current %>% filter(!is.na(WISC) & is.na(HOME_SCORE)) %>% nrow()` people missing `HOME` but not `WISC`. This is `r round((16/(343-32))*100, 2)`% of 311 (total with WISC).  
  
**Are the people missing WISC the same as the people missing maternal IQ?**  
  
There are `r ppp_current %>% filter(is.na(M_IQ)) %>% nrow()` people missing `maternal IQ` and `r ppp_current %>% filter(!is.na(WISC) & is.na(M_IQ)) %>% nrow()` people missing `maternal IQ` but not `WISC`. This is `r round((8/(343-32))*100,2)`% of 311. Two people are missing both `HOME` and `maternal IQ`.
  
**Can age 9 HOME predict age 7?**  
  
`all:`  
`lm(formula = HOMETOT ~ HOME_TOT9, data = combo)`  
`---`  
`Residuals:`  
`    Min      1Q  Median      3Q     Max `  
`-17.716  -2.943   1.099   3.830  10.645 `  
`---`  
`Coefficients:`  
`            Estimate Std. Error t value Pr(>|t|)     `  
`(Intercept) 30.41181    2.95846  10.280  < 2e-16 *** `  
`HOME_TOT9    0.22694    0.07178   3.161  0.00201 **  `  
`---`  
`Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1`  
`---`  
`Residual standard error: 5.696 on 115 degrees of freedom`   
`  (610 observations deleted due to missingness)`  
`Multiple R-squared:  0.07996,	Adjusted R-squared:  0.07196 `  
`F-statistic: 9.995 on 1 and 115 DF,  p-value: 0.002008`   
  

**Can age 9 WISC predict age 7?**  
  
`Call:` 
`lm(formula = WISC ~ WSC_CSFS_108, data = combo)`  
`---`  
`Residuals:`  
`    Min      1Q  Median      3Q     Max `  
`-23.622  -5.513  -0.530   5.378  23.562 `  
`---`  
`Coefficients:`  
`             Estimate Std. Error t value Pr(>|t|)    `  
`(Intercept)  23.46166    2.73993   8.563   <2e-16 ***`  
`WSC_CSFS_108  0.78160    0.02839  27.530   <2e-16 ***`  
`---`  
`Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1`  
`---`  
`Residual standard error: 7.938 on 461 degrees of freedom`  
`  (264 observations deleted due to missingness)`  
`Multiple R-squared:  0.6218,	Adjusted R-squared:  0.621 `  
`F-statistic: 757.9 on 1 and 461 DF,  p-value: < 2.2e-16`  
  
  
### Sensitivity

```{r, fig.height=7}
fit_sense_1 <- gam(WISC ~ s(P1, by = SEX) + SEX + M_IQ + ALCOHOL + M_EDU + 
                     MARITAL_STATUS + HOME_SCORE + M_AGE + SMOKER_IN_HOME, 
                 data = whole)
fit_sense_2 <- gam(WISC ~ s(P2, by = SEX) + SEX + M_IQ + ALCOHOL + M_EDU + MARITAL_STATUS + 
                     HOME_SCORE + M_AGE + SMOKER_IN_HOME,
                    data = whole)

ps_predict_1 = as_tibble(predict(fit_sense_1, se.fit = T))
ps_predict_2 = as_tibble(predict(fit_sense_2, se.fit = T))

mn_subset = whole %>% dplyr::select(SID, WISC, P_1 = P1, P_2 = P2, SEX, M_IQ, ALCOHOL, M_EDU, M_AGE, SMOKER_IN_HOME,
                                 MARITAL_STATUS, HOME_SCORE) %>% drop_na()

spline_pred = bind_cols(mn_subset, pred_1 = ps_predict_1$fit, se_1 = ps_predict_1$se.fit,
                                   pred_2 = ps_predict_2$fit, se_2 = ps_predict_2$se.fit) %>% 
              mutate(model = "Penalized Spline")

sense_all = bind_rows(spline_pred, pred) %>% 
  dplyr::select(-c(M_IQ, ALCOHOL, M_EDU, MARITAL_STATUS, HOME_SCORE, M_AGE, SMOKER_IN_HOME)) %>% 
  pivot_longer(c(P_1:P_2, pred_1:se_2),
               names_to = c("term", "pattern"),
               names_sep = "_") %>% 
  pivot_wider(names_from = term,
              values_from = value) %>% 
  mutate(extreme = ifelse(SID %in% c(453, 1209, 1229), "Yes", "No"),
         pattern = ifelse(pattern == "2", "Pattern 2", "Pattern 1"))

pal = brewer.pal(11, "RdBu")[c(2,4,11,10)]

sense_all %>% 
  ggplot(aes(x = P, fill = interaction(SEX, model))) +
  geom_point(aes(y = WISC), alpha=0.25, color="grey") +
  geom_point(aes(y = WISC), color="black",
             data = subset(sense_all, extreme =="Yes")) +
  geom_smooth(aes(y = pred, color = interaction(SEX, model)), 
              method = "gam", formula = y ~ s(x), se=F,
              data = subset(sense_all, model =="Penalized Spline"),
              linetype = 'dashed', fullrange = TRUE) +
    geom_smooth(aes(y = pred - 1.96*se, color = interaction(SEX, model)), 
              method = "gam", formula = y ~ s(x), se=F,
              data = subset(sense_all, model =="Penalized Spline"),
              linetype = 'dotted', size = 0.5, fullrange = TRUE) +
    geom_smooth(aes(y = pred + 1.96*se, color = interaction(SEX, model)), 
              method = "gam", formula = y ~ s(x), se=F,
              data = subset(sense_all, model =="Penalized Spline"),
              linetype = 'dotted', size = 0.5, fullrange = TRUE) +
  geom_smooth(aes(y = pred, color = interaction(SEX, model)),
              method = "lm", se=F,
              data = subset(sense_all, model =="Main Model"),
              fullrange = TRUE) +
    geom_smooth(aes(y = pred - 1.96*se, color = interaction(SEX, model)),
              method = "lm", se=F,
              data = subset(sense_all, model =="Main Model"),
              linetype = 'dotted', size = 0.5, fullrange = TRUE) +
    geom_smooth(aes(y = pred + 1.96*se, color = interaction(SEX, model)),
              method = "lm", se=F,
              data = subset(sense_all, model =="Main Model"),
              linetype = 'dotted', size = 0.5, fullrange = TRUE) +
  scale_fill_manual(values = pal, labels = c("", "Female", "", "Male")) +
  scale_color_manual(values = pal, labels = c("", "Female", "", "Male")) +
  facet_wrap(.~pattern, scales = "free_x") + 
  labs(y = "Full Scale WISC", x = "Pattern concentration") +
  theme(legend.title = element_blank())
```

#### Extreme values

```{r}
#bind_cols(mn_ppp, ewa) %>% filter(P2 > 30) %>% select(SID, P1, P2, everything())
  
extreme = bind_cols(mn_ppp, ewa) %>% filter(P2 > mean(P2) + 5*sd(P2)) %>%
  t() %>% as.data.frame() %>% rownames_to_column(var = "Chemical") %>% 
  mutate_at(vars(2:4), as.numeric) %>% 
  filter(Chemical != "SID")
```

```{r, figend, fig.height=10, fig.width=12}
mn_ppp %>%
  pivot_longer(MEHHP:BPA,
               names_to = "Chemical") %>% 
  left_join(., extreme) %>% 
  filter(grepl("^M", Chemical) | Chemical == "BPA") %>%
  filter(!(Chemical %in% c("MEP", "M_PB"))) %>% 
  mutate(Chemical = str_replace(Chemical, "_", "-")) %>% 
  ggplot(aes(x = value)) +
  geom_histogram(aes(y = ..density..), fill = "#0072B5", alpha=0.75) +
  geom_vline(aes(xintercept = V1), linetype = "dashed", color = "#E18727") + 
  geom_vline(aes(xintercept = V2), linetype = "dashed", color = "#20854E") + 
  geom_vline(aes(xintercept = V3), linetype = "dashed", color = "#F21A00") + 
  facet_wrap(Chemical~., scales = "free") + 
  labs(y = "Density", x="") +
  theme(axis.text.y = element_blank(),
        text = element_text(size = 30),
        axis.text.x = element_text(size = 10),
        axis.title.y = element_text(size = 35))
```

Highest female = Red  
2nd highest female = Green  
Highest male = Yellow  
  

